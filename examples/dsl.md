A model is generated by calling the `@fk` macro:

```julia
@fk function model()
    ...
end
```

The body can contain the following:

1. Assignments `y = expression`
Is processed to a FKStep with
- inputs= free variables in expression
- output= `:y`
- output_type= DataType
- sampler= `(particle) -> eval(replaced_expression)`
where `replaced_expression`replaces all free variables `x` with `particle[:x]`
- weighter= trivial weighter

Validate:
a. `y` must be variable symbol
b. `expression` must be well-formed

NEW: Rewrite to
for particle in particles 
    particle.y = replaced_expression


2. Sampling statements `y ~ f(args)`
Is processed to a FKStep with
- inputs= free variables on RHS
- output= `:y`
- output_type= f.output_type()
- sampler= `(particle,rng) -> f.sampler(replaced_args)`
where `replaced_args` replaces all free variables `x` in `args` with `particle[:x]`
- weighter= `(particle) -> f.weighter(replaced_args, particle[output])`

NEW: rewrite to
for (i,particle) in enumerate(particles)
    val = f.sampler(replaced_args,rng)
    particle.y = val
    weight[i] += f.weighter(replaced_args, val)
    
3. Observe statements `expr -> f(args)`
Is processed to a FKStep with
- inputs= free variables on RHS
- output= none
- output_type= f.output_type()
- sampler= trivial sampler
- weighter= `(particle) -> f.logpdf(replaced_args, eval(replaced_expr))`
Beware that `->` binds strongly, so you need to use parentheses in statements like `(1+1) -> f(args)`.

4. Loops `for i in 1:10 ... end`, `for i = 1:10 ... end` containing statements of types 1.-3.
Should be unrolled during parsing and loop variable interpolated.
